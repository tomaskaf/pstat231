---
title: "Final Project"
author: "Filip Tomaska, Kelli Woodward"
subtitle: PSTAT 131/231
output:
  html_document:
    toc: yes
    toc_float: yes
    code_folding: hide
    number_sections: yes
  pdf_document:
    toc: yes
---


#Abstract

Neuronal activity can be recorded using various recording techniques. Optophysiology provides an option using genetically encoded fluorescent reporters, which generate optical readout of neuronal activity.


# Introduction



```{r library loading, error=F, message=FALSE, warning=FALSE, echo=T}
library(R.matlab)
library(readr)
library(tidyverse)
library(data.table)
library(cluster)
library(dendextend)
library(factoextra)
library(ROCR)
```


# Pre-processing

## Data loading

```{r data import, error=F, warning=FALSE, echo=T, cache=TRUE}

dataMat <- R.matlab::readMat("sortAudFile.mat",fixNames=T, ) 
f19<-dataMat$sortAudFile[1]
f33<-dataMat$sortAudFile[2]
f34a<-dataMat$sortAudFile[3]
f34b <-dataMat$sortAudFile[4]
f34c <-dataMat$sortAudFile[5]
f35  <-dataMat$sortAudFile[6]
f37  <-dataMat$sortAudFile[7]
f38 <-dataMat$sortAudFile[8]
f40 <-dataMat$sortAudFile[9]
f41a <-dataMat$sortAudFile[10]
f41b <-dataMat$sortAudFile[11]
f42  <-dataMat$sortAudFile[12]
f43a <-dataMat$sortAudFile[13]
f43b <-dataMat$sortAudFile[14]
f44  <-dataMat$sortAudFile[15]

df<-as_tibble(f34c[[1]][[1]][[1]])

df = df %>% add_column(sound = 1)
df = df %>% add_column(day = 0)

tempF = f34c[[1]]

for (j in c(1:8)){
  for (i in c(1:39)) {
   df = df %>% add_row(tibble(as_tibble(tempF[i][[1]][[j]]),sound = i,day = j-1))
  }
  }
  

df$sound = factor(df$sound)
df$day = factor(df$day)



df.Day <-  df%>% filter(df$day==0)


df.neurons <-  df.Day%>% select(V1:V34)

```


# Exploratory

```{r, echo=T}

sumVect <- c(1:39)
  
for (i in c(1:39)) {
  df.sound = NULL
  df.sound <-  df%>% filter(df$sound==i)
  
  temp.df<- as.matrix(df.sound%>%select(V1:V34))

  sumVect[i] = sum(colSums(temp.df))
 
  sortSum = sort(sumVect, decreasing = TRUE)
  
  which(sumVect==(head(sortSum)[1]))
   
}


```



## hierarchical clustering

In order to


```{r Hierachical clustering, echo=T, warning=FALSE}

dist_mat <- dist(df.neurons,method = "euclidian")

fviz_dist(dist_mat, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
```
## looking at all days through a loop one by one

```{r,echo=T, warning=FALSE}

table.accum <- matrix(, nrow=2,ncol=8)
maxSecond <- matrix(, ncol=8)

for (k in c(0:7)){
  
  df.Day <-  df%>% filter(df$day==k)


df.neurons <-  df.Day%>% select(V1:V34)
dist_mat <- dist(df.neurons,method = "euclidian")


hclust_avg <- hclust(dist_mat, method = "average")
cut_avg <- cutree(hclust_avg, k = 2)




table.accum[,k+1] = table(cut_avg, df.Day$sound)[,34]
maxSecond[k+1] = as.numeric(which.max(table(cut_avg, df.Day$sound)[2,]))

}

table.accum
maxSecond
```


## looking at all days in one big dataset


```{r hclust with all days, warning=FALSE, echo=T}



df.neurons <-  df%>% select(V1:V34)
dist_mat <- dist(df.neurons,method = "euclidian")
#fviz_dist(dist_mat, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))


hclust_avg <- hclust(dist_mat, method = "complete")
cut_avg <- cutree(hclust_avg, k = 2)

## dendrogram: branches colored by 3 groups
dend1 = as.dendrogram(hclust_avg)

# color branches and labels by 3 clusters 
dend1 = color_branches(dend1, k=2)
dend1 = color_labels(dend1, k=2)
# change label size
dend1 = set(dend1, "labels_cex", 0.3) 
plot(dend1, horiz=T, main = "Dendrogram colored by three clusters")
cut_avg <- cutree(hclust_avg, k = 2)

table(cut_avg, df$sound)


```

## Resampling to show data is not random

```{r,echo=T}


dataMat <- R.matlab::readMat("sortAudFile.mat",fixNames=T, ) 
f19<-dataMat$sortAudFile[1]
f33<-dataMat$sortAudFile[2]
f34a<-dataMat$sortAudFile[3]
f34b <-dataMat$sortAudFile[4]
f34c <-dataMat$sortAudFile[5]
f35  <-dataMat$sortAudFile[6]
f37  <-dataMat$sortAudFile[7]
f38 <-dataMat$sortAudFile[8]
f40 <-dataMat$sortAudFile[9]
f41a <-dataMat$sortAudFile[10]
f41b <-dataMat$sortAudFile[11]
f42  <-dataMat$sortAudFile[12]
f43a <-dataMat$sortAudFile[13]
f43b <-dataMat$sortAudFile[14]
f44  <-dataMat$sortAudFile[15]

df<-as_tibble(f34c[[1]][[1]][[1]])

df = df %>% add_column(sound = 1)
df = df %>% add_column(day = 0)

tempF = f34c[[1]]

for (j in c(1:8)){
  for (i in c(2:39)) {
    sound.random = sample(c(1:39),1)
   df = df %>% add_row(tibble(as_tibble(tempF[i][[1]][[j]]), sound = sound.random, day = j-1))
  }
  }
  

df$sound = factor(df$sound)
df$day = factor(df$day)



df.Day <-  df%>% filter(df$day==0)


df.neurons <-  df.Day%>% select(V1:V34)


dist_mat <- dist(df.neurons,method = "euclidian")

fviz_dist(dist_mat, gradient = list(low = "#00AFBB", mid = "white", high = "#FC4E07"))
hclust_avg <- hclust(dist_mat, method = "complete")

cut_avg <- cutree(hclust_avg, k = 2)

table(cut_avg, df.Day$sound)

```


## lets try PCA

```{r, echo=T}

pca.neurons = prcomp(df.neurons, scale=TRUE)

pr.var <- (pca.neurons$sdev)^2
pve=pr.var/sum(pr.var)

 plot(pve, xlab="Principal Component",
     ylab="Proportion of Variance Explained ", ylim=c(0,1),type='b')
 
  plot(cumsum(pve), xlab="Principal Component ",
     ylab=" Cumulative Proportion of Variance Explained ", ylim=c(0,1), type='b')

abline(v =min(which((cumsum(pve)>=0.9))))

```

# Supervised learning

## Add a Factor variable 

```{r, include=FALSE}

df = df %>%
  mutate(s33=as.factor(ifelse(sound == "33", "Yes","No")))

```

```

## Split

```{r, include=FALSE}

df <- df %>% mutate(id = row_number())
#Check IDs
head(df$id)
#Create training set
train <- df %>% sample_frac(.70)
#Create test set
test  <- anti_join(df, train, by = 'id')

```


## logistic regression

```{r, echo=T}

model.glm = glm(formula = sound~.-id, data=train, family = binomial)
summary(model.glm)

```

```{r ,echo=T,message=FALSE,warning=FALSE}
calc_error_rate <- function(predicted.value, true.value){
  return(mean(true.value!=predicted.value)) }
```

```{r,echo=TRUE}

prob.training = as.integer(predict(model.glm, type="response")>0.5)

```

```{r,echo=T,message=FALSE,warning=FALSE}
trainError<- calc_error_rate(prob.training,train$sound)
testError<- calc_error_rate(prob.training,test$sound)


pred = prediction(prob.training, train$sound)
perf = performance(pred, measure="tpr", x.measure="fpr")

plot(perf, col=2, lwd=3, main="ROC curve")
abline(0,1)

auc = performance(pred, "auc")@y.values
auc


```
